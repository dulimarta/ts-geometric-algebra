# ts-geometric-algebra
Ts-geometric-algebra is a Clifford Algebra Generator for TypeScript and JavaScript. It generates Geometric Algebras of any signature and is mostly combatible with [Ganja.js](https://github.com/enkimute/ganja.js/). There is no operator overloading or inline functions yet due to lack of support in TypeScript.

(**Mathematically**, an algebra generated by ts-geometric-algebra is a graded exterior (Grassmann) algebra with a non-metric outer product, extended (Clifford) with geometric and contraction inner products, a Poincare duality operator and the main involutions and morphisms.)

(**Technically**, ts-geometric-algebra is a code generator producing classes that reificate algebraic literals.)

(**Practically**, ts-geometric-algebra enables algebraic operations over reals, complex numbers, dual numbers, hyperbolic numbers, vectors, spacetime events, quaternions, dual quaternions, biquaternions or any other Clifford Algebra with full type support from TypeScript.)

## Discourse and Discord

Visit [bivector.net](https://bivector.net) for our forum and chat - the perfect
place for questions and support.

### The Algebra Function

To create an Algebra, call the `Algebra` function specifying the metric
signature (number of positive, negative and zero dimensions). The result is
an ES6 class implementing the requested clifford algebra.

```typescript
function Algebra( p, q, r );
  // p    = number of positive dimensions.
  // q    = optional number of negative dimensions.
  // r    = optional number of zero dimensions.
```
An extended syntax is also available that allows you to further tweak the created Algebra.

```typescript
function Algebra( p, q, r, baseType, unroll )
  // p        = number of positive dimensions.
  // q        = optional number of negative dimensions.
  // r        = optional number of zero dimensions.
  // baseType = Float32Array or Float64Array
  // unroll   = (boolean) perform loop unrolling of performance critical methods
```
Here are some examples :

```typescript
// Basic
const Hyper   = Algebra(1);         // Hyperbolic numbers.
const Complex = Algebra(0, 1);      // Complex numbers.
const Dual    = Algebra(0, 0, 1);   // Dual numbers.
const H       = Algebra(0, 2);      // Quaternions.

// Clifford
const Cl2 = Algebra(2);             // Clifford algebra for 2D vector space.
const Cl3 = Algebra(3);             // Clifford algebra for 3D vector space.
const TimeSpace = Algebra(1, 3);    // Clifford algebra for timespace vectors.

// Geometric
const PGA2D = Algebra(2, 0, 1);     // Projective Euclidean 2D plane. (dual)
const PGA3D = Algebra(3, 0, 1);     // Projective Euclidean 3D space. (dual)
const CGA2D = Algebra(3, 1);        // Conformal 2D space.
const CGA3D = Algebra(4, 1);        // Conformal 3D space.

// High-Dimensional GA
const DCGA3D = Algebra(6, 2);       // Double Conformal 3D Space.
const TCGA3D = Algebra(9, 3);       // Triple Conformal 3D Space.
const DCGSTA = Algebra(4, 8);       // Double Conformal Geometric Space Time Algebra.
const QCGA   = Algebra(9, 6);       // Quadric Conformal Geometric Algebra.
```

You can now use these classes to generate algebraic elements. Those elements will have all of the
expected properties. (`norm`, blade access, `dot`, `wedge`, `mul`, `dual`, `inverse`, etc ...)

Unlike Ganja.js you must use them in a 'classic' programming style syntax like the example below.

```typescript
const Complex = Algebra(0, 1);       // Complex numbers.
const a = Complex.fromGanja([3, 2]); // 3 + 2i
const b = Complex.fromGanja([1, 4]); // 1 + 4i
return a.mul(b);                     // returns [-5, 14]
```
Altough not as pretty or fun as Ganja.js you have the full advantage of types and autocompletion.

### Methods

| Object oriented      | Function Oriented     | Ganja Equivalent | Explanation     |
|----------------------|-----------------------|------------------|-----------------|
| `x.equals(y)`        | `equals(x, y)`        | N/A              | Strict equality |
| `x.closeTo(y, tol?)` | `closeTo(x, y, tol?)` | N/A              | Equality within given tolerance |
| `x.hasNaN()`         | `hasNaN(x)`           | N/A              | Check for Not-a-Numbers |
| `x.hasInfinity()`    | `hasInfinity(x)`      | N/A              | Check for (negative) infinity |
| `x.isNil(tol?)`      | `isNil(x, tol?)`      | N/A              | Equal or close to zero |
| `x.isGrade(g, tol?)` | `isGrade(x, g, tol?)` | N/A              | Only has components of grade `g` |
| `x.s`                | N/A                   | `x.s`            | Scalar part (get/set) |
| `x.ps`               | N/A                   | N/A              | Pseudoscalar part (get/set) |
| `x.getAt(...idx)`    | N/A                   | N/A              | Metric-aware coefficient of the product of basis factors defined by `idx` |
| `x.setAt(...idx, a)` | N/A                   | N/A              | Set coefficient of product of basis factors `idx` as `a` |
| `x.norm()`           | `norm(x)`             | `x.Length`       | Conjugate norm (metric-aware) |
| `x.vnorm()`          | `vnorm(x)`            | `x.VLength`      | Vector norm (ignores metric) {`x.length` is array length} |
| `x.neg()`            | `neg(x)`              | N/A              | Negation (additive inverse) |
| `x.cwAbs()`          | `cwAbs(x)`            | N/A              | Component-wise absolute value |
| `x.involute()`       | `involute(x)`         | `x.Involute`     | Negation of basis factors |
| `x.rev()`            | `rev(x)`              | `x.Reverse`      | Reversal of basis factors {`x.reverse` is array reversal} |
| `x.conjugate()`      | `conjugate(x)`        | `x.Conjugate`    | Conjugation (combined involution and reversal) |
| `x.inverse()`        | `inverse(x)`          | `x.Inverse`      | Multiplicative inverse |
| `x.square()`         | `square(x)`           | `x.Mul(x)`       | Multiplicative squaring (**) |
| `x.normalize(a?)`    | `normalize(x, a?)`    | `x.Normalize`    | `x` with norm set to `a` (default 1) |
| `x.rotorNormalize()` | `rotorNormalize(x)`   | N/A              | Normalize rotor `x` |
| `x.sqrt()`           | `sqrt(x)`             | N/A              | Square root. Currently reliable only in dimensions < 2 |
| `x.rotorSqrt()`      | `rotorSqrt(x)`        | N/A              | Rotor square root. Available in certain metrics. |
| `x.exp()`            | `exp(x)`              | `x.Exp`          | Exponential function |
| `x.bivectorExp()`    | `bivectorExp(x)`      | `x.Exp`          | Bivector exponential function (optimized) |
| `x.log()`            | `log(x)`              | `x.Log`          | (Motor) Logarithm. Generic `exp` inverse available only in dimensions < 2 |
| `x.rotorLog()`       | `rotorLog(x)`         | `x.Log`          | Rotor Logarithm |
| `x.clone()`          | `clone(x)`            | `x.Scale(1)`     | Independent copy |
| `x.dual()`           | `dual(x)`             | `x.Dual` (*)     | Metric independent dual: `x.mul(x.dual()) = Cl.pseudoscalar()` |
| `x.undual()`         | `undual(x)`           | N/A              | Inverse of `x.dual()` |
| `x.scale(a)`         | `scale(x, a)`         | `x.Scale(a)`     | Scalar multiplication |
| `x.pow(n)`           | `pow(x, n)`           | `x.Pow(n)`       | Multiply `x` with itself `n` times |
| `x.applyWeights(ws)` | `applyWeights(x, ws)` | N/A              | Replace each basis factor with a weighted copy for every weight in `ws` |
| `x.negateGrades(...gs)` | `negateGrades(x, ...gs)` | `x.Map(...gs)` | Negate the given grades |
| `x.add(y)`           | `add(x, y)`           | `x.Add(y)`       | Component-wise addition (**) |
| `x.sub(y)`           | `sub(x, y)`           | `x.Sub(y)`       | Component-wise subtraction (**) |
| `x.mul(y)`           | `mul(x, y)`           | `x.Mul(y)`       | Geometric product of `x` and `y` (**) |
| `x.lmul(y)`          | `mul(y, x)`           | `y.Mul(x)`       | Geometric product from the left (**) |
| `x.div(y)`           | `div(x, y)`           | `x.Div(y)`       | Geometric division from the right |
| `x.ldiv(y)`          | `mul(inverse(y), x)`  | `y.Inverse.Mul(x)` | Left inverse product |
| `x.ldivs(y)`         | `mul(inverse(x), y)`  | `x.Inverse.Mul(y)` | Geometric division from the left |
| `x.wedge(y)`         | `wedge(x, y)`         | `x.Wedge(y)`     | Wedge (outer) product. Metric independent (**) |
| `x.lwedge(y)`        | `wedge(y, x)`         | `y.Wedge(x)`     | Wedge product from the left (**) |
| `x.vee(y)`           | `vee(x, y)`           | `x.Vee(y)`       | Vee (dual) product. Metric indepentend. `vee(x, y) = undual(dual(y), dual(x))` (**) |
| `x.lvee(y)`          | `vee(y, x)`           | `y.Vee(x)`       | Vee product from the left (**) |
| `x.rotorMean(y)`     | `rotorMean(x, y)`     | N/A              | Geometric mean of rotors `x` and `y` |
| `x.contract(y, ctn)` | `contract(x, y, ctn)` | N/A              | Contract `x` by `y` using criterion `ctn` |
| `x.dot(y)`           | `dot(x, y)`           | `x.Dot(y)`       | Dot product. Symmetric criterion (**) |
| `x.dotL(y)`          | `dotL(x, y)`          | `x.LDot(y)`      | Left contraction of `x` by `y` (**) |
| `x.ldotL(y)`         | `dotL(y, x)`          | `y.LDot(x)`      | Left contraction of `y` by `x` (**) |
| `x.dotR(y)`          | `dotR(x, y)`          | N/A              | Right contraction of `x` by `y` |
| `x.ldotR(y)`         | `dotR(y, x)`          | N/A              | Right contraction of `y` by `x` |
| `x.star(y)`          | `star(x, y)`          | N/A              | Scalar product. Nil criterion |
| `x.imag()`           | `imag(x)`             | N/A              | Filter out grade 0 |
| `x.even()`           | `even(x)`             | `x.Even()`       | Filter out odd grades |
| `x.grade(n)`         | `grade(x, n)`         | `x.Grade(n)`     | Keep only grade `n` components |
| `x.vector()`         | N/A                   | `x.Vector`       | Array of vector components |
| `x.vector(n)`        | N/A                   | N/A              | Array of `n`-vector components |
| `x.rotor()`          | N/A                   | N/A              | Array of components of even grade |
| `x.ganja()`          | N/A                   | `x`              | Array of all components in lexicographic order |
| `Cl.zero()`          | N/A                   | `Cl.Scalar(0)`   | Zero element |
| `Cl.scalar(a?)`      | N/A                   | `Cl.Scalar(a)`   | Scalar element of size `a` (default `1`) |
| `Cl.pseudoscalar(a?)` | N/A                  | N/A              | Pseudoscalar element of size `a` (default `1`) |
| `Cl.basisBlade(...idx)` | N/A                | N/A              | Unit basis blade given by the product of the given basis factors |
| `Cl.fromVector(vs)`  | N/A                   | `Cl.Vector(...vs)` | Vector element with given components (from an array) |
| `Cl.fromVector(vs, 2)` | N/A                 | `Cl.Bivector(...vs)` | Bivector element with given components (lexicographic order) |
| `Cl.fromVector(vs, 3)` | N/A                 | `Cl.Trivector(...vs)` | Trivector element with given components |
| `Cl.fromVector(vs, g)` | N/A                 | `Cl.nVector(g, ...vs)` | `g`-vector element with given components |
| `Cl.fromRotor(vs)`   | N/A                   | N/A              | Even grade element with given components |
| `Cl.fromGanja(vs)`   | N/A                   | `new Cl(vs)`     | New element with components given in lexicographic order |
| `Cl.dimensions`      | N/A                   | `-->` | `Math.log(Cl.describe().basis.length)/Math.log(2)` number of dimensions |
| `Cl.size`            | N/A                   | `-->` | `Cl.describe().basis.length` algebra size |
| `new Cl(vs)`         | N/A                   | N/A   | New element with components given in bit field order (Not recommended, use `fromGanja` instead) |

(*) Only in degenerate metrics
(**) Loop unrolled for maximum performance

### Dual Zoo
| Object oriented      | Function Oriented     | Ganja Equivalent    | Explanation     |
|----------------------|-----------------------|---------------------|-----------------|
| `x.podge()`          | `podge(x)`            | `x.Mul(ps)`         | Right-multiplication by `Cl.pseudoscalar()` |
| `x.unpodge()`        | `unpodge(x)`          | `x.Div(ps)`         | Right-division by `Cl.pseudoscalar()` |
| `x.podgeL()`         | `podgeL(x)`           | `ps.Mul(x)`         | Left-multiplication by `Cl.pseudoscalar()` |
| `x.unpodgeL()`       | `unpodgeL(x)`         | `ps.Inverse.Mul(x)` | Left-division by `Cl.pseudoscalar()` |
| `x.star()`           | `star(x)`             | N/A                 | Non-degenerate `x.podge()` |
| `x.unstar()`         | `unstar(x)`           | N/A                 | Inverse of `x.star()` |
| `x.starL(x)`         | `starL(x)`            | `x.Dual` (*)        | Non-degenerate `x.podgeL()` |
| `x.unstarL(x)`       | `unstarL(x)`          | N/A                 | Inverse of `x.starL()` |
| `x.hodge()`          | `hodge(x)`            | N/A                 | Hodge dual |
| `x.unhodge()`        | `unhodge(x)`          | N/A                 | Inverse of `x.hodge()` |
| `x.hodgeL()`         | `hodgeL(x)`           | N/A                 | Left Hodge dual |
| `x.unhodgeL()`       | `unhodgeL(x)`         | N/A                 | Inverse of `x.hodgeL()` |

(*) Only in non-degenerate metrics

#### Rotor operation availability
| Metric (pqr) | Available operations |
|--------------|----------------------|
| p+q+r <= 2   | (all)                |
| 400          | `rotorSqrt`, `rotorNormalize` |
| 310          | `rotorSqrt`, `rotorNormalize` |
| 301          | `rotorLog`, `rotorSqrt`, `rotorNormalize` |
| 410          | `rotorSqrt`, `rotorNormalize` |
